<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Loading Diagram Generator</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.2/dist/svg.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.draggable.js@3.0.4/dist/svg.draggable.js"></script>
    </head>
    <style>
        body {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
        #UI {
            width: 500px;
            font-family: "Trebuchet MS", Helvetica, sans-serif;
            font-size: 14px;
        }
        h3 {
            margin-bottom: 0;
        }
        label {
            display: inline-block;
            width: 50%;
        }
        input[type="number"], input[type="text"], select {
            width: 50%;
            box-sizing: border-box;
        }
        textarea {
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }
        input[type="checkbox"] {
            display: inline-block;
            vertical-align: middle;
        }
        button {
            margin-top: 20px;
        }
        details {
            margin-top: 1.17em;
        }
        summary > h3 {
            margin: 0;
            display: inline;
        }
    </style>
    <body>
        <div id="UI">
            <h1>Loading Diagram Generator</h1>
            <details>
                <summary><h3>About</h3></summary>
                <p>
                    <b>Purpose/Scope:</b>
                    Automatically generate a to-scale vessel loading diagram without building from scratch using shapes in an image editor.
                    The only important data required are the vessel dimensions and the heights of each layer;
                    elevations/depths are automatically calculated.
                    All other settings are related to graphical/data formatting.
                </p>
                <p>
                    <b>Usage:</b> Collect layers and materials data in a spreadsheet, following the column format specified below.
                    Save as .csv, then copy and paste raw data into text boxes below.
                    Each time settings are modified, click Update Drawing to generate SVG image.
                    Download .svg, open in browser to view/print, or make adjustments first in Visio if needed.
                </p>
                <p>
                    <b>Privacy Policy:</b> All calculations are done locally, no data is collected on any server.
                </p>
                <p>
                    Copyright (c) 2024 Luke Arcamo, released under MIT license.
                    <a href="https://github.com/svgdotjs/svg.js">SVG.js</a> v3.2 is the only dependency, also released under MIT license.
                </p>
                <p>
                    Check out <a href="https://github.com/lukearcamo">my GitHub page</a> if you would like to modify the code for finer customization or provide feedback/feature suggestions.
                </p>
            </details>
            <h3>CSV Layer Data</h3>
            Columns: Material Name, Height (in" or ft' in"), Color (#hex or <a href="https://www.w3schools.com/cssref/css_colors.php">CSS name</a>)<br>
            <textarea id="layerData" spellcheck="false" rows="4">Bed 1 Hardware,1' 4",grey
Bed 1 Gap,1' 5",transparent
1/4" Inert Balls,6",cornflowerblue
Catalyst 1,5' 5",gold
Catalyst 2,10' 1",tomato
1/4" Inert Balls,6",cornflowerblue
Bed 2 Hardware,7' 8",grey
Bed 2 Gap,1' 5",none
1/4" Inert Balls,6",cornflowerblue
Catalyst 1,5' 5",gold
Catalyst 2,10' 1",tomato
Bed 3 Hardware,7' 8",grey
Bed 3 Gap,1' 5",none
1/4" Inert Balls,6",cornflowerblue
Catalyst 1,5' 5",gold
Catalyst 2,10' 1",tomato
1/4" Inert Balls,6",cornflowerblue
1" Inert Balls,3' 6",cornflowerblue</textarea>
            <h3>CSV Material Data</h3>
            Columns: Material Name, Bulk Density (lb/ft3), Qty/Pkg, UoM (lb or ft3)<br>
            <textarea id="materialData" spellcheck="false" rows="4">Catalyst 1,40.2,200,lb
Catalyst 2,38.1,200,lb
1/4" Ceramic Balls,75.3,25,ft3
1" Ceramic Balls,75.3,25,ft3</textarea>
            <h3>Dimensions</h3>
            <label for="innerDiameter">Inner Diameter (in): </label><input type="number" id="innerDiameter" min="0" value="150" step="0.0625"><br>
            <label for="tanToTan">Tangent to Tangent (in): </label><input type="number" id="tanToTan" min="0" value="800" step="0.0625"><br>
            <label for="headWidthToHeightRatio">Head Shape: </label><select name="headWidthToHeightRatio" id="headWidthToHeightRatio">
                <option value="1">Hemispherical</option>
                <option value="2">Ellipsoidal 2:1</option>
            </select><br>
            <label for="topFlangeHeight">Top Flange Height (in): </label><input type="number" id="topFlangeHeight" min="0" value="40" step="0.0625"><br>
            <label for="outletCollectorHeight">Outlet Collector Height (in): </label><input type="number" id="outletCollectorHeight" min="0" value="25" step="0.0625"><br>

            <h3>Markings</h3>
            <label for="direction">Direction: </label><select name="direction" id="direction">
                <option value="absoluteDepth">Absolute Depth</option>
                <option value="absoluteElevation">Absolute Elevation</option>
                <option value="relativeDepth">Relative Depth</option>
                <option value="relativeElevation">Relative Elevation</option>
            </select><br>
            <label for="referenceLineOffset">Ref. Line (for abs. depth/elev.) (in): </label><input type="number" id="referenceLineOffset" value="-40" step="0.0625"><br>
            <label for="feetInches">ft' in": </label><input type="checkbox" id="feetInches" checked><br>
            <label for="splitLayers">Split layers: </label><input type="checkbox" id="splitLayers" checked> (e.g. tan. lines, outlet collector)<br>
            <label for="displayData">Display Data: </label><select name="displayData" id="displayData">
                <option value="volume">Volume (ft3)</option>
                <option value="mass">Mass (lb)</option>
                <option value="numPkgs">Number of bags/drums</option>
            </select><br>
            
            <br>
            List of zero-outage reference layers:<br>
            <textarea id="zeroLayers" spellcheck="false" rows="1">Bed 2 Gap, Bed 3 Gap</textarea>
            <br>
            <br>
            List of notch gap layers:<br>
            <textarea id="notchGapLayers" spellcheck="false" rows="1">Bed 2 Hardware, Bed 3 Hardware</textarea>
            
            <h3>File</h3>
            <label for="equipmentTag">Equipment Tag: </label><input type="text" id="equipmentTag" value="AA-R-000"><br>
            <button id="updateDrawing">Update Drawing</button>
            <button id="downloadSVG">Download .svg</button>
            
            <details>
                <summary><h3>Advanced Formatting</h3></summary>
                <label for="fontSize">Font Size (px): </label><input type="number" id="fontSize" min="0" value="6"><br>
                <label for="marginLeft">Margin Left (px): </label><input type="number" id="marginLeft" min="0" value="60"><br>
                <label for="marginRight">Margin Right (px): </label><input type="number" id="marginRight" min="0" value="200"><br>
                <label for="marginTop">Margin Top (px): </label><input type="number" id="marginTop" min="0" value="10"><br>
                <label for="marginBottom">Margin Bottom (px): </label><input type="number" id="marginBottom" min="0" value="10"><br>
                <label for="notchWidth">Notch Width (px): </label><input type="number" id="notchWidth" min="0" value="10"><br>
                <label for="shapesDraggable">Shapes Draggable: </label><input type="checkbox" id="shapesDraggable"> (Warning: Resets if updated)<br>
            </details>

            <details>
                <summary><h3>Save/Restore Settings</h3></summary>
                Copy/paste JSON here:
                <textarea id="settingsJSON" spellcheck="false" rows="4"></textarea>
                <!-- <button id="downloadSettings">Download settings as .json</button> -->
                <button id="restoreSettings">Restore settings from JSON</button>
                <button id="saveSettings">Save settings to JSON</button>
            </details>
        </div>
        <script>
            //============================================//
            // Define Parameters
            //============================================//
            
            var layerData = [];
            var requiresReprocessData = true;

            var settings = {
                innerDiameter: 150,
                tanToTan: 800,
                headWidthToHeightRatio: 1,
                topFlangeHeight: 40,
                outletCollectorHeight: 25,

                direction: "Absolute Depth",
                referenceLineOffset: -40,
                feetInches: true,
                splitLayers: true,
                displayData: "volume", // Other options: mass, numPkgs
                zeroLayers: ["Bed 2 Gap", "Bed 3 Gap"],
                notchGapLayers: ["Bed 2 Hardware", "Bed 3 Hardware"],

                equipmentTag: "AA-R-000",

                fontSize: 6,
                marginLeft: 70,
                marginRight: 250,
                marginTop: 10,
                marginBottom: 10,
                notchWidth: 10,
            };

            // Parameters to be calculated from settings
            var headHeight, shellHeight, reactorHeight, maskThickness;

            function getInputs() {
                for (var key of Object.keys(settings)) {
                    var input = document.getElementById(key);
                    if (input != null) {
                        if (input.type == "checkbox") {
                            settings[key] = input.checked;
                        }
                        else if (input.tagName == "TEXTAREA") {
                            settings[key] = input.value.replaceAll(/,\s+/g, ",").split(",");
                        }
                        else if (input.type == "number" || key == "headWidthToHeightRatio") {
                            settings[key] = parseFloat(input.value);
                        }
                        else {
                            settings[key] = input.value;
                        }
                    }
                }
                headHeight = settings.innerDiameter / 2 / settings.headWidthToHeightRatio;
                shellHeight = settings.tanToTan + headHeight * 2;
                reactorHeight = settings.topFlangeHeight + shellHeight;
                maskThickness = Math.sqrt(settings.innerDiameter**2 / 2) - settings.innerDiameter / 2;
            }
            function setInputs() {
                for (var key of Object.keys(settings)) {
                    var input = document.getElementById(key);
                    if (input != null) {
                        if (input.type == "checkbox") {
                            input.checked = settings[key];
                        }
                        else if (input.tagName == "TEXTAREA") {
                            input.value = settings[key].join(", ");
                        }
                        else {
                            input.value = settings[key];
                        }
                    }
                }
            }

            //============================================//
            // Utility Functions
            //============================================//

            function inchesToFeetInches(x) {
                return Math.trunc(x / 12) + "\' " + parseFloat(Math.abs(x % 12).toFixed(4)) + "\"";
            }   
            function feetInchesToInches(str) {
                if (str.search(/['"]/) != -1) {
                    var feet = str.match(/(\d+)'/);
                    feet = feet == null ? 0 : parseInt(feet[1]);
                    var inches = str.match(/([\d.]+)"/);
                    inches = inches == null ? 0 : parseFloat(inches[1]);
                }
                else {
                    return parseInt(str);
                }
                return feet * 12 + inches;
            }
            function layerVolume(inches) { // Approximate only; loses accuracy when layer is within shell head
                return Math.PI * settings.innerDiameter**2 / 4 * inches / 1728; // UoM: ft3
            }

            //============================================//
            // Process Data Before Rendering
            //============================================//

            var splitElevations = [];

            function addLayer(material, label, layerHeight, color, absoluteElevation, relativeElevation) {
                var mass = undefined;
                var numPkgs = undefined;

                if (absoluteElevation >= splitElevations[0]) {
                    var heightAbove = absoluteElevation - splitElevations[0];
                    var heightBelow = layerHeight - heightAbove;
                    if (heightBelow > 0) {
                        var volume = layerVolume(heightBelow);
                        if (material != undefined) {
                            mass = volume * material.bulkDensity;
                            numPkgs = (material.qtyUoM == "lb" ? mass : volume) / material.qtyPerPkg;
                        }

                        layerData.push({
                            height: heightBelow,
                            absoluteElevation: absoluteElevation - heightAbove,
                            relativeElevation: relativeElevation - heightAbove,
                            label, color, borderStyle: "dashed",
                            volume, mass, numPkgs,
                        });
                    }
                    
                    splitElevations.shift();
                    
                    if (heightAbove > 0) {
                        addLayer(material, label, heightAbove, color, absoluteElevation, relativeElevation);
                    }
                }
                else {
                    var volume = layerVolume(layerHeight);
                    if (material != undefined) {
                        mass = volume * material.bulkDensity;
                        numPkgs = (material.qtyUoM == "lb" ? mass : volume) / material.qtyPerPkg;
                    }

                    layerData.push({
                        height: layerHeight,
                        absoluteElevation: absoluteElevation,
                        relativeElevation: relativeElevation,
                        label, color, borderStyle: "solid",
                        volume, mass, numPkgs,
                    });
                }
            }
            function processData() {
                splitElevations = [1e9];
                if (settings.splitLayers) { 
                    splitElevations = [settings.outletCollectorHeight, headHeight, headHeight + settings.tanToTan, shellHeight]; // Must be in order, lowest to highest
                }

                var materialData = {};
                var splitLines = document.getElementById("materialData").value.split("\n");
                for (var line of splitLines) {
                    if (line == "") continue;
                    line = line.split(",");
                    materialData[line[0]] = {
                        bulkDensity: parseFloat(line[1]),
                        qtyPerPkg: parseFloat(line[2]),
                        qtyUoM: line[3],
                    };
                }

                layerData = []; // Clear layerData
                splitLines = document.getElementById("layerData").value.split("\n");
                splitLines.reverse();

                var absoluteElevation = 0;
                var relativeElevation = 0;

                // Calculate absolute/relative elevation first
                for (var line of splitLines) {
                    if (line == "") continue;
                    line = line.split(",");
                    var layerHeight = feetInchesToInches(line[1]);
                    var material = materialData[line[0]];
                    
                    absoluteElevation += layerHeight;
                    relativeElevation += layerHeight;

                    if (settings.zeroLayers.includes(line[0])) relativeElevation = 0;

                    addLayer(material, line[0], layerHeight, line[2], absoluteElevation, relativeElevation);
                }


                // Fill the remaining space on top
                var remainingSpace = reactorHeight - absoluteElevation;
                if (remainingSpace > 0) {
                    absoluteElevation += remainingSpace;
                    relativeElevation += remainingSpace;

                    addLayer(undefined, "Remaining Space", remainingSpace, "none", absoluteElevation, relativeElevation);
                }

                layerData.reverse();
                layerData[0].borderStyle = "none";

                // Add bottommost notch label:
                addLayer(undefined, "", 0, "none", 0, 0);

                // Calculate absolute/relative depth
                var relativeDepth = 0;
                for (var row of layerData) {
                    row.absoluteDepth = shellHeight - row.absoluteElevation;
                    if (settings.zeroLayers.includes(row.label)) relativeDepth = 0;
                    row.relativeDepth = relativeDepth;
                    relativeDepth += row.height;
                }
            }
            
            //============================================//
            // Initialize Drawing
            //============================================//

            const draw = SVG().addTo('body').insertBefore("#UI");
            var mask = draw.rect(100, 100);
            var outline = draw.rect(100, 100);
            var topFlange = draw.rect(100, 100);
            var outletCollector = draw.rect(100, 100);

            const clearableShapes = [];

            function update() {
                //============================================//
                // Obtain Parameters from GUI
                //============================================//
                getInputs();

                const isAbsolute = settings.direction.includes("absolute");
                const isDepth = settings.direction.includes("Depth");

                if (requiresReprocessData) {
                    requiresReprocessData = false;
                    processData();
                }

                //============================================//
                // Apply Reactor Dimensions
                //============================================//

                var totalLayersHeight = layerData[0].absoluteElevation;
                draw.size(
                    settings.innerDiameter + settings.marginLeft + settings.marginRight,
                    Math.max(totalLayersHeight, reactorHeight) + settings.marginTop + settings.marginBottom
                );
                draw.viewbox(
                    -settings.marginLeft,
                    shellHeight - Math.max(totalLayersHeight, reactorHeight) - settings.marginTop,
                    draw.width(),
                    draw.height()
                );

                mask.size(settings.innerDiameter + maskThickness, shellHeight + maskThickness);
                mask.move(-maskThickness / 2, -maskThickness / 2);
                mask.radius(settings.innerDiameter / 2 + maskThickness / 2, headHeight + maskThickness / 2);
                mask.stroke({ color: "white", width: maskThickness });
                mask.fill("none");

                outline.size(settings.innerDiameter, shellHeight);
                outline.radius(settings.innerDiameter / 2, headHeight);
                outline.stroke({ color: "black", width: 1 });
                outline.fill("none");
                
                topFlange.size(settings.topFlangeHeight, settings.topFlangeHeight);
                topFlange.cx(settings.innerDiameter / 2);
                topFlange.y(-settings.topFlangeHeight);
                topFlange.stroke({ color: "black", width: 1 });
                topFlange.fill("none");
                
                outletCollector.size(settings.outletCollectorHeight, settings.outletCollectorHeight);
                outletCollector.cx(settings.innerDiameter / 2);
                outletCollector.y(shellHeight - settings.outletCollectorHeight);
                outletCollector.stroke({ color: "black", width: 1 });
                outletCollector.fill("none");
                outletCollector.insertBefore(mask);

                //============================================//
                // Draw Layers
                //============================================//

                clearableShapes.forEach(x => x.remove());
                for (var row of layerData) {
                    if (row.color != "none" && row.color != "transparent") {
                        var background = draw.rect(settings.innerDiameter, row.height);
                        background.move(0, row.absoluteDepth);
                        background.fill(row.color);
                        background.back();
                        clearableShapes.push(background);
                    }

                    if (row.borderStyle != "none") {
                        var border = draw.line(0, 0, settings.innerDiameter, 0);
                        border.move(0, row.absoluteDepth);
                        border.stroke({ color: "black", width: 1, dasharray: row.borderStyle == "dashed" ? "4 4" : "1 0" });
                        border.insertBefore(mask);
                        clearableShapes.push(border);
                    }

                    var outletCollectorDepth = shellHeight - settings.outletCollectorHeight;
                    if (row.label != "") {
                        var appendToLabel = "";
                        if (settings.displayData == "volume") {
                            var isWithinBottomHead = row.absoluteDepth + row.height > shellHeight - headHeight;
                            var isWithinTopHead = row.absoluteDepth < headHeight;
                            appendToLabel = " [" + (isWithinBottomHead || isWithinTopHead ? "<" : "") + row.volume.toFixed(2) + " ft3]";
                        } else if (settings.displayData == "mass" && row.mass != undefined) {
                            appendToLabel = " [" + row.mass.toFixed(2) + " lbs]";
                        } else if (settings.displayData == "numPkgs" && row.numPkgs != undefined) {
                            appendToLabel = " [~" + row.numPkgs.toFixed(1) + " pkgs]";
                        }
                        var layerText = draw.text(row.label + appendToLabel);
                        layerText.font({ anchor: "middle", size: settings.fontSize, weight: "bold", leading: 1, family: "Helvetica" });
                        layerText.center(settings.innerDiameter / 2, row.absoluteDepth + row.height / 2); // Order of font and positioning matters!
                        clearableShapes.push(layerText);
                    }

                    // Right-side notches
                    if (isAbsolute || !settings.notchGapLayers.includes(row.label)) {
                        var notchRight = draw.polyline([[0, 0], [settings.notchWidth, 0], [settings.notchWidth / 2, 0], [settings.notchWidth / 2, row.height], [settings.notchWidth, row.height], [0, row.height]]);
                        notchRight.move(settings.innerDiameter + settings.notchWidth, row.absoluteDepth);
                        notchRight.fill("none").stroke({ color: "black", width: 1 });
                        clearableShapes.push(notchRight);
                    }
                    
                    var notchValueRight = isAbsolute ? row[settings.direction] - settings.referenceLineOffset : row[settings.direction];
                    notchValueRight = settings.feetInches ? inchesToFeetInches(notchValueRight) : parseFloat(notchValueRight.toFixed(4)) + "\"";
                    var notchTextRight = draw.text(notchValueRight);
                    notchTextRight.font({ anchor: "start", size: settings.fontSize, leading: 1, family: "Helvetica" });
                    notchTextRight.x(settings.innerDiameter + settings.notchWidth * 2.5);
                    notchTextRight.cy(row.absoluteDepth);
                    clearableShapes.push(notchTextRight);

                    // Left-side notches
                    if (row.height > 0) {
                        var notchLeft = draw.polyline([[settings.notchWidth, 0], [0, 1], [0, row.height - 1], [settings.notchWidth, row.height]]);
                        notchLeft.move(-settings.notchWidth * 2, row.absoluteDepth);
                        notchLeft.fill("none").stroke({ color: "black", width: 1 });
                        clearableShapes.push(notchLeft);
                        
                        var notchValueLeft = settings.feetInches ? inchesToFeetInches(row.height) : parseFloat(row.height.toFixed(4)) + "\"";
                        var notchTextLeft = draw.text(notchValueLeft);
                        notchTextLeft.x(-settings.notchWidth * 2.5); // Order matters for some reason; different from right-side notches!
                        notchTextLeft.font({ anchor: "end", size: settings.fontSize, leading: 1, family: "Helvetica" });
                        notchTextLeft.cy(row.absoluteDepth + row.height / 2);
                        notchTextLeft.rebuild(true);
                        clearableShapes.push(notchTextLeft);
                    }
                }
                
                //============================================//
                // Draw Miscellaneous Features
                //============================================//
                
                // Draw reference line
                if (isAbsolute && settings.referenceLineOffset > 0) {
                    var referenceLine = draw.line(0, 0, settings.innerDiameter, 0);
                    referenceLine.move(0, isDepth ? settings.referenceLineOffset : shellHeight - settings.referenceLineOffset);
                    referenceLine.stroke({ color: "black", width: 2 });
                    referenceLine.insertBefore(mask);
                    clearableShapes.push(referenceLine);
                }

                // Add document info
                var currentDate = new Date();
                var month = currentDate.toLocaleString("default", { month: "short" });
                var docInfo = draw.text(add => {
                    add.tspan(settings.equipmentTag).font({ weight: "bold" });
                    add.tspan("Loading Diagram").font({ weight: "bold" }).newLine();
                    add.tspan(month + ". " + currentDate.getFullYear()).newLine();
                    add.tspan("").newLine();
                    add.tspan(`ID: ${inchesToFeetInches(settings.innerDiameter)} = ${settings.innerDiameter}"`).newLine();
                    add.tspan(`TT: ${inchesToFeetInches(settings.tanToTan)} = ${settings.tanToTan}"`).newLine();
                });
                docInfo.x(draw.width() - settings.marginRight + settings.marginLeft);
                docInfo.font({ anchor: "middle", size: 14, family: "Helvetica" });
                clearableShapes.push(docInfo);

                updateDraggability();
            }
            
            update();
            document.getElementById("settingsJSON").value = JSON.stringify(settings, null, " ");

            //============================================//
            // Define Interactive Behaviour
            //============================================//

            setTimeout(function () { // Fix for page scrolled down when page/svg loaded
                window.scrollTo(0, 0);
            }, 12);
            document.getElementById("updateDrawing").addEventListener("click", update);
            document.getElementById("downloadSVG").addEventListener("click", e => {
                var fileName = settings.equipmentTag.replace(/\s/g, "_") + "_Loading_Diagram.svg";
                var file = new File([draw.svg()], fileName, { type: "image/svg+xml" });
                var url = URL.createObjectURL(file);
                var a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
            });
            document.getElementById("restoreSettings").addEventListener("click", e => {
                settings = JSON.parse(document.getElementById("settingsJSON").value);
                setInputs();
                requiresReprocessData = true;
                update();
            });
            document.getElementById("saveSettings").addEventListener("click", e => {
                update();
                document.getElementById("settingsJSON").value = JSON.stringify(settings, null, " ");
            });
            function updateDraggability() {
                var shapesDraggable = document.getElementById("shapesDraggable").checked;
                clearableShapes.forEach(x => {
                    if (shapesDraggable) {
                        x.draggable(true);
                        x.attr({ style: "cursor: move"});
                    }
                    else {
                        x.draggable(false);
                        x.attr({ style: "cursor: unset"});
                    }
                });
            }
            document.getElementById("shapesDraggable").addEventListener("click", updateDraggability);

            // Parameters that require data reprocessing when updated:
            document.getElementById("tanToTan").addEventListener("input", e => requiresReprocessData = true);
            document.getElementById("headWidthToHeightRatio").addEventListener("input", e => requiresReprocessData = true);
            document.getElementById("topFlangeHeight").addEventListener("input", e => requiresReprocessData = true);
            document.getElementById("outletCollectorHeight").addEventListener("input", e => requiresReprocessData = true);
            document.getElementById("layerData").addEventListener("input", e => requiresReprocessData = true);
            document.getElementById("materialData").addEventListener("input", e => requiresReprocessData = true);
            document.getElementById("zeroLayers").addEventListener("input", e => requiresReprocessData = true);
            document.getElementById("notchGapLayers").addEventListener("input", e => requiresReprocessData = true);
            document.getElementById("splitLayers").addEventListener("input", e => requiresReprocessData = true);
        </script>
    </body>
</html>
